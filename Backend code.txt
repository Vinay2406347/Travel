package com.example.travelinsuranceservice;

// Import required Spring Boot classes
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

 
/**
 * Main entry point for the Spring Boot Travel Insurance & Assistance module.
 *
 * What this file does:
 * ðŸ”¹ Marks the starting point of the application
 * ðŸ”¹ Enables auto-configuration, component scanning, and bean registration
 * ðŸ”¹ Boots up the Spring application context and starts the embedded server (Tomcat)
 *
 * Annotations used:
 * @SpringBootApplication is a combination of:
 *   - @Configuration: marks this class as a source of bean definitions
 *   - @EnableAutoConfiguration: tells Spring Boot to auto-configure beans based on dependencies
 *   - @ComponentScan: scans this package and all sub-packages for Spring components
 */
@EnableFeignClients(basePackages="com.example.travelinsuranceservice.client")
@SpringBootApplication
@EnableDiscoveryClient //Enables Eureka client functionality
public class TravelInsuranceApplication {
 
    /**
     * Main method that gets executed when the application starts.
     *
     * @param args command-line arguments (optional)
     */
    public static void main(String[] args) {
        // Launch the Spring Boot application
        SpringApplication.run(TravelInsuranceApplication.class, args);
    }
}

 package com.example.travelinsuranceservice.client;
 
import com.example.travelinsuranceservice.dto.BookingDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
 
/**
* Feign client to communicate with the Booking module.
*/
@FeignClient(name = "TravelBooking-PaymentModule")
public interface BookingClient {
 
    /**
     * Fetch booking details by bookingId from the Booking module.
     * @param bookingId the ID of the booking
     * @return the BookingDTO containing booking information
     */
    @GetMapping("/api/bookings/internal/{id}")
    BookingDTO getBookingById(@PathVariable("id") Long bookingId);
}

package com.example.travelinsuranceservice.client;
 
import com.example.travelinsuranceservice.dto.UserDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
 
/**
 * Feign client to communicate with the User module.
 */
@FeignClient(name = "usermanagement-service")
public interface UserClient {
 
    /**
     * Fetch user details by userId from the User module.
     * @param long1 the ID of the user
     * @return the UserDTO containing user information
     */
    @GetMapping("/api/users/internal/customer/{id}")
    UserDTO getUserById(@PathVariable("id") Long userId);
}

 package com.example.travelinsuranceservice.controller;
 
import com.example.travelinsuranceservice.dto.AssistanceRequestDTO;
import com.example.travelinsuranceservice.model.AssistanceRequest;
import com.example.travelinsuranceservice.service.AssistanceRequestService;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
 
import java.util.List;
 
/**
 * Controller for handling assistance-related requests.
 */
@RestController
@RequestMapping("/api/assistance")
public class AssistanceRequestController {
 
    private static final Logger logger = LoggerFactory.getLogger(AssistanceRequestController.class);
 
    @Autowired
    private AssistanceRequestService service;
 
    /**
     * POST /api/assistance
     * Create a new assistance request for a user.
     */
    @PostMapping
    public ResponseEntity<AssistanceRequest> requestHelp(@Valid @RequestBody AssistanceRequestDTO dto) {
        logger.info("Creating assistance request for userId: {}", dto.getUserId());
        AssistanceRequest request = service.createRequest(dto);
        return new ResponseEntity<>(request, HttpStatus.CREATED);
    }
 
    /**
     * PUT /api/assistance/{requestId}/status?status=Resolved
     * Update the status of an assistance request.
     */
    @PutMapping("/{requestId}/status")
    public ResponseEntity<AssistanceRequest> updateStatus(@PathVariable Integer requestId,
                                                   @RequestParam String status) {
        logger.info("Updating assistance status for requestId {} to {}", requestId, status);
        return ResponseEntity.ok(service.updateStatus(requestId, status));
    }
 
    /**
     * GET /api/assistance/user/{userId}
     * Fetch all assistance requests made by a user.
     */
    @GetMapping("/user/{userId}")
    public ResponseEntity<List<AssistanceRequest>> getByUser(@PathVariable Long userId) {
        logger.info("Fetching assistance requests for userId: {}", userId);
        return ResponseEntity.ok(service.getByUser(userId));
    }
}
 
 
 package com.example.travelinsuranceservice.controller;
 
import com.example.travelinsuranceservice.dto.*;
import com.example.travelinsuranceservice.model.CoverageType;
import com.example.travelinsuranceservice.model.Insurance;
import com.example.travelinsuranceservice.service.InsuranceService;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
 
import java.util.*;
import java.util.stream.Collectors;
 
/**
 * Controller exposing REST end-points for insurance operations.
 */
@RestController
@RequestMapping("/api/insurance")
public class InsuranceController {
 
    private static final Logger logger = LoggerFactory.getLogger(InsuranceController.class);
 
    @Autowired
    private InsuranceService service;
    
 
 
    /**
     * POST /api/insurance
     * Creates new insurance with fixed status "ISSUED".
     */
    @PostMapping
    public ResponseEntity<Insurance> createInsurance(@Valid @RequestBody InsuranceRequestDTO dto) {
        logger.info("POST /api/insurance - creating insurance");
        Insurance insurance = service.createInsurance(dto);
        return new ResponseEntity<>(insurance, HttpStatus.CREATED);
    }
 
 
    /**
     * GET /api/insurance/user/{userId}
     * Fetches insurance policies for a given user.
     */
    @GetMapping("/user/{userId}")
    public ResponseEntity<List<Insurance>> getByUser(@PathVariable Long userId) {
        logger.info("GET /api/insurance/user/{} - Fetching insurance list", userId);
        return ResponseEntity.ok(service.getUserInsurance(userId));
    }
    
   
 
    /**
     * GET /api/insurance/coverage-plans
     * Returns available coverage options (name, price, details, claim).
     */
    @GetMapping("/coverage-plans")
    public ResponseEntity<List<CoveragePlanDTO>> getCoveragePlans() {
        logger.info("GET /api/insurance/coverage-plans - Fetching all coverage plans");
 
        List<CoveragePlanDTO> plans = Arrays.stream(CoverageType.values())
                .map(type -> new CoveragePlanDTO(
                        type.name(),
                        type.getCoverageDetails(),
                        type.getPrice(),
                        type.getClaimableAmount()))
                .collect(Collectors.toList());
 
        return ResponseEntity.ok(plans);
    }
    
    @PutMapping("/{insuranceId}/booking/{bookingId}")
    public ResponseEntity<String> updateInsuranceBookingId(
            @PathVariable Integer insuranceId,
            @PathVariable Long bookingId) {
     
        logger.info("PUT /api/insurance/{}/booking/{} - Linking insurance to booking", insuranceId, bookingId);
     
        String result = service.updateBookingIdInInsurance(insuranceId, bookingId);
     
        return ResponseEntity.ok(result);
    }

     
     
    
    /**
    * GET /api/insurance/price/{userId}
    * Fetch insurance price selected by userId
    */
    @GetMapping("/price/{userId}")
    public ResponseEntity<Double> getInsurancePriceByUserId(@PathVariable Long userId) {
    logger.info("GET /api/insurance/price/{} - Fetching insurance price", userId);
     
        double price = service.getInsurancePriceByUserId(userId);
     
        if (price <= 0) {
            logger.warn("No insurance found for userId: {}", userId);
            return ResponseEntity.notFound().build();
        }
     
    logger.info("Insurance price for userId {} is {}", userId, price);
        return ResponseEntity.ok(price);
    }
    /**
     * GET /api/insurance/price/{insuranceId}
     * Fetch insurance price selected by insuranceId
     */
    @GetMapping("/price/insurance/{insuranceId}")
    public ResponseEntity<Double> getInsurancePriceByInsuranceId(@PathVariable Integer insuranceId) {
        logger.info("GET /api/insurance/price/insurance/{} - Fetching insurance price by insuranceId", insuranceId);

        double price = service.getInsurancePriceByInsuranceId(insuranceId);

        if (price <= 0) {
            logger.warn("No insurance found for insuranceId: {}", insuranceId);
            return ResponseEntity.notFound().build();
        }

        logger.info("Insurance price for insuranceId {} is {}", insuranceId, price);
        return ResponseEntity.ok(price);
    }
    
    @GetMapping("/validate/{insuranceId}")
    public ResponseEntity<Boolean> validateInsurance(@PathVariable Integer insuranceId) {
        boolean exists = service.validateInsuranceId(insuranceId);
        return ResponseEntity.ok(exists);
    }

}

 package com.example.travelinsuranceservice.dto;
 
import jakarta.validation.constraints.NotNull;
import lombok.Data;
 
/**
 * DTO used to receive a new assistance request from the user.
 */
@Data
public class AssistanceRequestDTO {
 
    @NotNull(message = "User ID is required")
    private Long userId;
 
    @NotNull(message = "Issue description is required")
    private String issueDescription;
}
 
package com.example.travelinsuranceservice.dto;
 
import lombok.Data;
 
import java.time.LocalDate;
 
@Data
public class BookingDTO {
    private Long bookingId;
    private Integer userId;
    private Integer packageId;
    private LocalDate startDate;
    private LocalDate endDate;
    private String status;
    private Integer paymentId;
}
 
package com.example.travelinsuranceservice.dto;
 
import lombok.AllArgsConstructor;
import lombok.Data;
 
/**
 * DTO to expose insurance coverage plans to Booking module.
 */
@Data
@AllArgsConstructor
public class CoveragePlanDTO {
    private String coverageType;       // BASIC, STANDARD, PREMIUM
    private String coverageDetails;    // Human-readable description
    private Double price;              // Fixed price per plan
    private Double claimableAmount;    // Max claim amount per plan
}
 
package com.example.travelinsuranceservice.dto;
 
import lombok.Data;
 
/**
* DTO to expose insurance coverage plans to Booking module.
*/
@Data
public class InsuranceRequestDTO {
   
    private Integer insuranceId;
 
    private Long userId;
 
    private Long bookingId;  // To be updated after successful payment
 
    private String coverageDetails;
    
    private String coverageType;
 
    private double price;
 
    private String provider;
 
    private String status;  // e.g., "PENDING", "ISSUED"
}

package com.example.travelinsuranceservice.dto;
 
import lombok.Data;
 
/**
 * Used to receive user details from the User module.
 */
@Data
public class UserDTO {
    private Long id;
    private String name;
    private String email;
    private String role;
}
 
 
 package com.example.travelinsuranceservice.exception;
 
import org.springframework.http.*;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.*;
 
import java.util.*;
 
/**
 * Handles all exceptions across the application in a unified format.
 */
@RestControllerAdvice
public class GlobalExceptionHandler {
 
    // Handles custom not-found exceptions
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, String>> handleNotFound(ResourceNotFoundException ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
 
    // Handles input validation failures (e.g. null fields, missing @Valid values)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidation(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors()
                .forEach(e -> errors.put(e.getField(), e.getDefaultMessage()));
        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
    }
 
    // Handles invalid user/booking ID validation via Feign clients
    @ExceptionHandler(InvalidInputException.class)
    public ResponseEntity<Map<String, String>> handleInvalidInput(InvalidInputException ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
 
    // Handles any other unexpected exception
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleGeneral(Exception ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", "Unexpected error: " + ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
 
 
 package com.example.travelinsuranceservice.exception;
 
/**
 * Custom exception used when user or booking ID is invalid.
 * Thrown when validation via Feign client fails.
 */
public class InvalidInputException extends RuntimeException {
 
    private static final long serialVersionUID = 1L;
 
    public InvalidInputException(String message) {
        super(message);
    }
}
 
package com.example.travelinsuranceservice.exception;
 
/**
 * Custom exception to be thrown when an entity is not found.
 * Used for insuranceId and requestId not present in DB.
 */
public class ResourceNotFoundException extends RuntimeException {
 
    // Added to avoid serialization warning
    private static final long serialVersionUID = 1L;
 
    /**
     * Constructor that passes the error message to parent RuntimeException.
     *
     * @param message details of the exception
     */
    public ResourceNotFoundException(String message) {
        super(message); // Calls parent class constructor
    }
}
 
 package com.example.travelinsuranceservice.model;
 
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import lombok.NoArgsConstructor;
 
import java.time.LocalDateTime;
 
/**
 * Entity class mapped to 'assistance_request' table.
 * Auto-generates request timestamp and has fixed resolution time.
 */
@Entity
@Data
@NoArgsConstructor
public class AssistanceRequest {
 
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer requestId; // Auto-generated primary key
 
    @NotNull(message = "User ID cannot be null")
    private Long userId; // Provided by external module
 
    @NotNull(message = "Issue description cannot be empty")
    private String issueDescription; // Reason for assistance (e.g. Lost passport)
 
    private String status = "Active"; // Default status at creation
 
    private String resolutionTime = "24 hours"; // Always fixed
 
    private LocalDateTime requestTimestamp; // Date + time of request
 
    /**
     * Automatically sets the time-stamp before insertion.
     */
    @PrePersist
    public void setRequestTimestamp() {
        this.requestTimestamp = LocalDateTime.now();
    }
}
 
 package com.example.travelinsuranceservice.model;
 
import lombok.Getter;
 
/**
 * Enum to represent predefined coverage types.
 * Each type has fixed coverage details, price, and claimable amount.
 * Lombok @Getter is used to generate getter methods for each field.
 */
@Getter
public enum CoverageType {
 
    BASIC("Covers emergency medical expenses and trip cancellation for domestic travel.", 500.0, 100000.0),
    STANDARD("Includes medical coverage, trip cancellation, lost baggage, and flight delay protection.", 1000.0, 200000.0),
    PREMIUM("Comprehensive coverage including international medical support, evacuation, trip interruption, and personal liability", 2000.0, 500000.0);
 
    private final String coverageDetails;
    private final Double price;
    private final Double claimableAmount;
 
    /**
     * Constructor to initialize enum values.
     *
     * @param coverageDetails description of coverage
     * @param price price of the coverage
     * @param claimableAmount amount claimable under this plan
     */
    CoverageType(String coverageDetails, Double price, Double claimableAmount) {
        this.coverageDetails = coverageDetails;
        this.price = price;
        this.claimableAmount = claimableAmount;
    }
}
 
 package com.example.travelinsuranceservice.model;
 
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
 
import java.time.LocalDateTime;
 
/**
 * Entity representing an insurance policy for travel booking.
 */
@Entity
@Data
public class Insurance {
 
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer insuranceId;
 
    @NotNull(message = "User ID cannot be null")
    private Long userId;
 
    // Booking ID will be updated later from the Booking module
    @Column(name="booking_id")
    private Long bookingId;
 
    @Enumerated(EnumType.STRING)
    @NotNull(message = "Coverage type is required")
    private CoverageType coverageType;
 
    // Fields populated based on coverageType at creation
    private String coverageDetails;
    private Double price;
    private Double claimableAmount;
 
    // Default Status Pending
    @Column(nullable=false)
    private String issuanceStatus = "PENDING";
    
    @Column(nullable=false)
    private String provider="Secure Travel Insurance Co.";
 
    @CreationTimestamp
    private LocalDateTime createdAt;
 
    /**
     * Automatically sets coverageDetails, price, and claimableAmount
     * before saving to DB based on the selected coverageType.
     */
    @PrePersist
    public void setDefaults() {
        if (coverageType != null) {
            this.coverageDetails = coverageType.getCoverageDetails();
            this.price = coverageType.getPrice();
            this.claimableAmount = coverageType.getClaimableAmount();
        }
    }
}
 
 
 package com.example.travelinsuranceservice.repository;
 
import com.example.travelinsuranceservice.model.AssistanceRequest;
import org.springframework.data.jpa.repository.JpaRepository;
 
import java.util.List;
 
/**
 * Repository interface for AssistanceRequest entity.
 * Provides CRUD operations and custom method to search by userId.
 */
public interface AssistanceRequestRepository extends JpaRepository<AssistanceRequest, Integer> {
 
    /**
     * Returns all assistance requests submitted by a specific user.
     *
     * @param userId ID of the user
     * @return List of AssistanceRequest objects
     */
    List<AssistanceRequest> findByUserId(Long userId);
}
 
 
 package com.example.travelinsuranceservice.repository;
 
import com.example.travelinsuranceservice.model.Insurance;
import org.springframework.data.jpa.repository.JpaRepository;
 
import java.util.List;
import java.util.Optional;
 
/**
 * Repository interface for Insurance entity.
 * Extends JpaRepository to get CRUD operations automatically.
 */
public interface InsuranceRepository extends JpaRepository<Insurance, Integer> {
 
    /**
     * Custom finder method to retrieve all insurance records for a given userId.
     * Spring Data JPA automatically generates the query from the method name.
     *
     * @param userId ID of the user
     * @return List of Insurance objects associated with the user
     */
    List<Insurance> findByUserId(Long userId);
    
    List<Insurance> findByUserIdAndBookingIdIsNull(Long userId);

	boolean existsByInsuranceId(Integer insuranceId);

	Optional<Insurance> findById(Integer insuranceId);
	
	Optional<Insurance> findByBookingId(Long bookingId);
}
 
 
 package com.example.travelinsuranceservice.service;
 
import com.example.travelinsuranceservice.client.UserClient;
import com.example.travelinsuranceservice.dto.AssistanceRequestDTO;
import com.example.travelinsuranceservice.exception.*;
import com.example.travelinsuranceservice.model.AssistanceRequest;
import com.example.travelinsuranceservice.repository.AssistanceRequestRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
import java.util.List;
 
/**
 * Business logic for managing Assistance requests.
 */
@Service
public class AssistanceRequestService {
 
    private static final Logger logger = LoggerFactory.getLogger(AssistanceRequestService.class);
 
    @Autowired
    private AssistanceRequestRepository repo;
 
    @Autowired
    private UserClient userClient;
 
    /**
     * Validates user and creates a new assistance request.
     */
    public AssistanceRequest createRequest(AssistanceRequestDTO dto) {
        logger.info("Validating userId: {}", dto.getUserId());
        if (userClient.getUserById(dto.getUserId()) == null) {
            logger.error("Invalid userId: {}", dto.getUserId());
            throw new InvalidInputException("Invalid user ID: " + dto.getUserId());
        }
 
        AssistanceRequest request = new AssistanceRequest();
        request.setUserId(dto.getUserId());
        request.setIssueDescription(dto.getIssueDescription());
 
        logger.info("Saving new assistance request for userId: {}", dto.getUserId());
        return repo.save(request);
    }
 
    /**
     * Updates the status of an existing assistance request.
     */
    public AssistanceRequest updateStatus(Integer requestId, String status) {
        AssistanceRequest req = repo.findById(requestId)
                .orElseThrow(() -> new ResourceNotFoundException("Request not found: " + requestId));
        req.setStatus(status);
        logger.info("Updated status for requestId {} to {}", requestId, status);
        return repo.save(req);
    }
 
    /**
     * Fetches all assistance records for a specific user.
     */
    public List<AssistanceRequest> getByUser(Long userId) {
        logger.info("Fetching assistance list for userId: {}", userId);
        return repo.findByUserId(userId);
    }
}
 
 
 package com.example.travelinsuranceservice.service;

import com.example.travelinsuranceservice.client.BookingClient;
import com.example.travelinsuranceservice.client.UserClient;
import com.example.travelinsuranceservice.dto.BookingDTO;
import com.example.travelinsuranceservice.dto.InsuranceRequestDTO;
import com.example.travelinsuranceservice.exception.InvalidInputException;
import com.example.travelinsuranceservice.exception.ResourceNotFoundException;
import com.example.travelinsuranceservice.model.CoverageType;
import com.example.travelinsuranceservice.model.Insurance;
import com.example.travelinsuranceservice.repository.InsuranceRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

/**
 * Service class handling business logic for Insurance module.
 */
@Service
public class InsuranceService {

    private static final Logger logger = LoggerFactory.getLogger(InsuranceService.class);

    @Autowired
    private InsuranceRepository repo;

    @Autowired
    private UserClient userClient;

    @Autowired
    private BookingClient bookingClient;

    /**
     * Creates new insurance entry for a user
     * 			
     */
    public Insurance createInsurance(InsuranceRequestDTO dto) {
    	logger.info("Creating insurance for userId: {}, coverageType: {}", dto.getUserId(), dto.getCoverageType());
    	 
    	        // Step 1: Validate user via UserClient (Feign)
    	        if (userClient.getUserById(dto.getUserId()) == null) {
    	            throw new InvalidInputException("Invalid user ID: " + dto.getUserId());
    	        }
    	 
    	        // Step 2: If bookingId is present, check for duplicate insurance for that booking
    	        if (dto.getBookingId() != null) {
    	            Optional<Insurance> existing = repo.findByBookingId(dto.getBookingId());
    	            if (existing.isPresent()) {
    	                throw new InvalidInputException("Insurance already exists for this booking.");
    	            }
    	        } 
    	        else {
    	            // Step 3: If bookingId is not present (user hasn't booked yet), block if they already selected insurance
    	            if (!repo.findByUserIdAndBookingIdIsNull(dto.getUserId()).isEmpty()) {
    	                throw new InvalidInputException("You already have a pending insurance. Please complete booking first.");
    	            }
    	        }
    	 
    	        // Step 4: Create Insurance entity with selected coverage
    	        Insurance insurance = new Insurance();
    	        insurance.setUserId(dto.getUserId());
    	 
    	        // Only set bookingId if present (initially it may be null)
    	        if (dto.getBookingId() != null) {
    	            insurance.setBookingId(dto.getBookingId());
    	        }
    	 
    	        // Set coverage fields from enum
    	        CoverageType type = CoverageType.valueOf(dto.getCoverageType().toUpperCase());
    	        insurance.setCoverageType(type);
    	        insurance.setCoverageDetails(type.getCoverageDetails());
    	        insurance.setPrice(type.getPrice());
    	        insurance.setClaimableAmount(type.getClaimableAmount());
    	 
    	        insurance.setIssuanceStatus("PENDING"); // initial status
    	 
    	        // Step 5: Save and return
    	        Insurance saved = repo.save(insurance);
    	logger.info("Insurance created with ID: {}", saved.getInsuranceId());
    	        return saved;
    	    }

    /**
     * Returns all insurance records for the given userId.
     */
    public List<Insurance> getUserInsurance(Long userId) {
        logger.info("Fetching insurance list for userId: {}", userId);
        return repo.findByUserId(userId);
    }

    /**
     * Returns the price of the first valid insurance selected by the user.
     * Used by Booking module to calculate total cost.
     */
    public double getInsurancePriceByUserId(Long userId) {
        logger.info("Fetching insurance price for userId: {}", userId);

        List<Insurance> insurances = repo.findByUserId(userId);
        if (insurances.isEmpty()) {
            logger.warn("No insurance found for userId {}", userId);
            return 0.0;
        }

        Insurance insurance = insurances.get(0);

        if ("CANCELLED".equalsIgnoreCase(insurance.getIssuanceStatus())) {
            logger.info("Insurance is cancelled for userId {}", userId);
            return 0.0;
        }

        logger.info("Returning insurance price {} for insuranceId {}", insurance.getPrice(), insurance.getInsuranceId());
        return insurance.getPrice();
    }
    
    public double getInsurancePriceByInsuranceId(Integer insuranceId) {
        logger.info("Fetching insurance price for insuranceId: {}", insuranceId);

        Insurance insurance = repo.findById(insuranceId).orElse(null);

        if (insurance == null) {
            logger.warn("No insurance found for insuranceId {}", insuranceId);
            return 0.0;
        }

        if ("CANCELLED".equalsIgnoreCase(insurance.getIssuanceStatus())) {
            logger.info("Insurance is cancelled for insuranceId {}", insuranceId);
            return 0.0;
        }

        logger.info("Returning insurance price {} for insuranceId {}", insurance.getPrice(), insuranceId);
        return insurance.getPrice();
    }

    /**
     * Called by Booking module after booking/payment is successful.
     * Updates bookingId and sets issuanceStatus = "ISSUED".
     */
    public String updateBookingIdInInsurance(Integer insuranceId, Long bookingId) {
        Insurance insurance = repo.findById(insuranceId)
                .orElseThrow(() -> new ResourceNotFoundException("Insurance not found"));

        BookingDTO booking = bookingClient.getBookingById(bookingId);
        if (booking == null) {
            throw new InvalidInputException("Invalid booking ID: " + bookingId);
        }

        insurance.setBookingId(bookingId);
        insurance.setIssuanceStatus("ISSUED");

        repo.save(insurance);

        return "Insurance linked to booking successfully.";
    }

    /**
     * Validates if the given insurance ID exists in the repository.
     */
    public boolean validateInsuranceId(Integer insuranceId) {
        return repo.existsByInsuranceId(insuranceId);
    }
}

spring.application.name=TravelInsuranceService

# MySQL database connection
spring.datasource.url=jdbc:mysql://localhost:3306/insurance_db
spring.datasource.username=root
spring.datasource.password=root
 
# Hibernate will create and update tables based on entity classes
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
 
# App port
server.port=8085

#Eureka Registration
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
eureka.instance.prefer-ip-address=true
 
 #Feign Configuration
 spring.cloud.openfeign.client.default.connectTimeout=5000
 spring.cloud.openfeign.client.default.readTimeout=5000
 
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.1.12</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.example</groupId>
	<artifactId>TravelInsuranceService</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>TravelInsuranceService</name>
	<description>Demo project for Spring Boot</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-openfeign</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>2022.0.5</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>


package com.example.discoveryserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication //basic springboot setup
@EnableEurekaServer	//Tells spring that this is a eureka server
public class DiscoveryServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(DiscoveryServerApplication.class, args);
	}

}

spring.application.name=discovery-server

#port to run Eureka Server
server.port=8761
#Telling spring cloud not to register itself since its the server
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false


package com.example.apigateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient //Enables Eureka client functionality
public class ApiGatewayApplication {

	public static void main(String[] args) {
		SpringApplication.run(ApiGatewayApplication.class, args);
	}

}

package com.example.apigateway.config;

import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayRoutesConfig {
	
	@Bean
	public RouteLocator gatewayRoutes(RouteLocatorBuilder builder) {
		return builder.routes()
				// Route to user-service
				.route("usermanagement-service", route -> route
					    .path("/api/users/**")
					    
					    .uri("lb://usermanagement-service")) // send to service named "usermanagement-service"
				
		
				// Routes for Travel Package Management Service
				.route("travel-package-management", route -> route
						.path("/api/packages/**")
			    
						.uri("lb://travel-package-management")) // send to service named "travel-package-management"
				
				// Routes for Travel Insurance Service
				.route("TravelInsurance", route -> route
						.path("/api/insurance/**")
			    
						.uri("lb://TravelInsuranceService")) // send to service named "TravelInsuranceService"
				
				// Routes for Travel Assistance Service
				.route("TravelAsssistance", route -> route
						.path("/api/assistance/**")
			    
						.uri("lb://TravelInsuranceService")) // send to service named "TravelInsuranceService"
				

				// Route to reviews-service
				.route("reviews-service", route -> route
					    .path("/api/reviews/**")
					    
					    .uri("lb://RatingsAndReview"))  // send to service named "ratings-and-review-service"
				// Route to review-service
				.route("agent-responses-service", route -> route
					    .path("/api/agent-responses/**")
					    
					    .uri("lb://RatingsAndReview")) // send to service named "ratings-and-review-service"
				// Route to Booking and Payment Module
				.route("booking-service", route -> route
					    .path("/api/bookings/**")
					    
					    .uri("lb://TravelBooking-PaymentModule"))  // send to service named "TravelBooking_PaymentModule"
				// Route to payment end points
				.route("payment-service", route -> route
					    .path("/api/payments/**")
					    
					    .uri("lb://TravelBooking-PaymentModule")) // send to service named "TravelBooking_PaymentModule"

				.build(); // Only one build() at the end

						
	}

}
#port where api-gateway will run
server.port=8080

#register with eureka
spring.application.name=api-gateway
#tells the location of eureka to register apigateway into it
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
# Enable detailed debug logging for Spring Cloud Gateway components.
# This helps trace how requests are routed, filtered, and processed.
logging.level.org.springframework.cloud.gateway=DEBUG

# Enable debug logging for the underlying Netty HTTP client used by the gateway.
# Useful for inspecting low-level HTTP request and response details.
logging.level.reactor.netty.http.client=DEBUG

eureka.instance.prefer-ip-address=false
eureka.instance.hostname=localhost

spring.main.web-application-type=reactive
#-------------
# Define route for usermanagement-service
spring.cloud.gateway.routes[0].id=usermanagement-service
 
# Send matching requests to Eureka-registered service named usermanagement-service
spring.cloud.gateway.routes[0].uri=lb://usermanagement-service
 
# Match both /api/users/** and /api/auth/** to forward to the usermanagement-service
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/users/**,/api/auth/**
#---------------
# Define route for travel-package-management-service
spring.cloud.gateway.routes[1].id=travel-package-management
 
# Send matching requests to Eureka-registered service named travel-package-management-service
spring.cloud.gateway.routes[1].uri=lb://travel-package-management
 
# Match both /api/users/** and /api/auth/** to forward to the travel-package-management-service
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/packages/**


# New route for Ratings and Review service
spring.cloud.gateway.routes[2].id=RatingsAndReview
spring.cloud.gateway.routes[2].uri=lb://RatingsAndReview
spring.cloud.gateway.routes[2].predicates[0]=Path=/api/reviews/**,/api/agent-responses/**

# New route for Travel Insurance Service
spring.cloud.gateway.routes[3].id=TravelInsuranceService
spring.cloud.gateway.routes[3].uri=lb://TravelInsuranceService
spring.cloud.gateway.routes[3].predicates[0]=Path=/api/insurance/**,/api/assistance/**


# New route for TravelBooking_PaymentModule
# Route to Booking service
spring.cloud.gateway.routes[4].id=TravelBooking-PaymentModule
spring.cloud.gateway.routes[4].uri=lb://TravelBooking-PaymentModule
spring.cloud.gateway.routes[4].predicates[0]=Path=/api/bookings/**,/api/payments/**
#spring.cloud.gateway.routes[4].filters[0]=RewritePath=/api/(?<segment>.*),/api/$\{segment}



#CORS Config for Angular App
spring.cloud.gateway.globalcors.corsConfigurations.[/**].allowedOrigins=http://localhost:4200
spring.cloud.gateway.globalcors.corsConfigurations.[/**].allowedMethods=GET,POST,PUT,DELETE,OPTIONS
spring.cloud.gateway.globalcors.corsConfigurations.[/**].allowedHeaders=*
spring.cloud.gateway.globalcors.corsConfigurations.[/**].allowCredentials=true

<project
xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
 
    <groupId>com.example</groupId>
    <artifactId>api-gateway</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>api-gateway</name>
 
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.12</version>
        <relativePath/>
    </parent>
 
    <properties>
        <java.version>17</java.version>
        <spring-cloud.version>2022.0.4</spring-cloud.version>
    </properties>
 
    <dependencies>
        <!-- Spring Cloud Gateway (add manually) -->
        <dependency>
<groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
 
        <!-- Eureka Discovery Client -->
        <dependency>
<groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        
        
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-gateway-server</artifactId>
			<version>4.0.5</version> <!-- Matches 2022.0.4 BOM -->
		</dependency>


		<!-- Spring Boot Starter Test (JUnit + Spring Test) -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		
        
    </dependencies>

	<!-- Import Spring Cloud BOM for compatibility -->
    <dependencyManagement>
        <dependencies>
            <dependency>
<groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
 
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>




Some refernce from booking module
package com.booking.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;

/**
 * Feign client for interacting with the Travel Insurance Service.
 * 
 * This client provides methods to retrieve insurance prices, validate insurance,
 * and update booking IDs for insurance records.
 */
@FeignClient(name = "TravelInsuranceService", url = "http://localhost:8085")
public interface TravelInsuranceClient {

    /**
     * Retrieve the insurance price for a specific user.
     * 
     * @param userId The ID of the user.
     * @return The insurance price for the user.
     */
    @GetMapping("/api/insurance/price/user/{userId}")
    double getInsurancePriceByUserId(@PathVariable("userId") Long userId);

    /**
     * Retrieve the insurance price for a specific insurance ID.
     * 
     * @param insuranceId The ID of the insurance.
     * @return The insurance price for the insurance ID.
     */
    @GetMapping("/api/insurance/price/insurance/{insuranceId}")
    double getInsurancePriceByInsuranceId(@PathVariable("insuranceId") Integer insuranceId);

    /**
     * Validate the insurance by its ID.
     * 
     * @param insuranceId The ID of the insurance to be validated.
     * @return true if the insurance is valid, false otherwise.
     */
    @GetMapping("/api/insurance/validate/{insuranceId}")
    boolean validateInsurance(@PathVariable("insuranceId") Integer insuranceId);

    /**
     * Update the booking ID for a specific insurance record.
     * 
     * @param insuranceId The ID of the insurance.
     * @param bookingId The ID of the booking.
     * @return A message indicating the result of the update operation.
     */
    @PutMapping("/api/insurance/{insuranceId}/booking/{bookingId}")
    String updateInsuranceBookingId(@PathVariable("insuranceId") Integer insuranceId, @PathVariable("bookingId") Long bookingId);
}


package com.booking.controller;

import com.booking.dto.BookingDTO;
import jakarta.validation.Valid;
import com.booking.entity.Booking;
import com.booking.service.BookingService;
import com.booking.response.ApiResponse;
import com.booking.dto.TravelPackageDTO;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.logging.Logger;

/**
 * Controller for handling booking-related requests.
 * 
 * This controller provides endpoints for creating, retrieving, updating, and deleting bookings.
 */
@CrossOrigin(origins = "http://localhost:4200")
@RestController
@RequestMapping("/api/bookings")
public class BookingController {

    private final BookingService service;
    private static final Logger logger = Logger.getLogger(BookingController.class.getName());

    /**
     * Constructor for BookingController.
     * 
     * @param service The BookingService instance to be used by this controller.
     */
    public BookingController(BookingService service) {
        this.service = service;
    }

    /**
     * Create a new booking.
     * 
     * @param booking The booking entity to be created.
     * @return ResponseEntity containing the created BookingDTO and HTTP status.
     */
    @PostMapping
    public ResponseEntity<?> createBooking(@Valid @RequestBody Booking booking) {
        try {
            BookingDTO bookingDTO = service.createBooking(booking);
            return new ResponseEntity<>(bookingDTO, HttpStatus.CREATED);
        } catch (RuntimeException ex) {
            ex.printStackTrace(); // shows full error in backend logs
            logger.severe("Error creating booking: " + ex.getMessage());

            // return a proper error JSON message to frontend
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                 .body(new ApiResponse(false, "Booking failed: " + ex.getMessage(), null));
        }
    }
    /**
     * Retrieve all bookings.
     * 
     * @return ResponseEntity containing the list of all bookings and HTTP status.
     */
    @GetMapping
    public ResponseEntity<List<Booking>> getAllBookings() {
        List<Booking> bookings = service.getAllBookings();
        return ResponseEntity.ok(bookings);
    }

    /**
     * Retrieve a booking by its ID.
     * 
     * @param id The ID of the booking to be retrieved.
     * @return ResponseEntity containing the booking and HTTP status.
     */
    @GetMapping("/{id}")
    public ResponseEntity<Booking> getBookingById(@PathVariable Long id) {
        Booking booking = service.getBookingById(id);
        if (booking == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(booking);
    }

    /**
     * Cancel a booking by its ID.
     * 
     * @param id The ID of the booking to be canceled.
     * @return ResponseEntity containing the cancellation status and HTTP status.
     */
    @PutMapping("/cancel/{id}")
    public ResponseEntity<String> cancelBooking(@PathVariable Long id) {
        return service.cancelBooking(id);
    }

    /**
     * Delete a booking by its ID.
     * 
     * @param id The ID of the booking to be deleted.
     */
    @DeleteMapping("/{id}")
    public void delete(@PathVariable Long id) {
        service.deleteBooking(id);
    }

    /**
     * Retrieve bookings by user ID.
     * 
     * @param userId The ID of the user whose bookings are to be retrieved.
     * @return ResponseEntity containing the list of bookings and HTTP status.
     */
    @GetMapping("/internal/bookings/user/{userId}")
    public ResponseEntity<List<Booking>> getBookingsByUserId(@PathVariable Long userId) {
        List<Booking> bookings = service.getBookingsByUserId(userId);
        // If the list is empty, return 200 OK with an empty list, not 404
        return ResponseEntity.ok(bookings); // <--- CHANGE THIS LINE
    }
//    @GetMapping("/internal/bookings/user/{userId}")
//    public ResponseEntity<List<Booking>> getBookingsByUserId(@PathVariable Long userId) {
//        List<Booking> bookings = service.getBookingsByUserId(userId);
//        if (bookings.isEmpty()) {
//            return ResponseEntity.notFound().build();
//        }
//        return ResponseEntity.ok(bookings);
//    }
    /**
     * Check if a user has completed a package.
     * 
     * @param userId The ID of the user.
     * @param packageId The ID of the package.
     * @return boolean indicating whether the user has completed the package.
     */
    @GetMapping("/user/{userId}/package/{packageId}/completed")
    public boolean hasUserCompletedPackage(@PathVariable Long userId, @PathVariable String packageId) {
        return service.hasUserCompletedPackage(userId, packageId);
    }

    /**
     * Retrieve a booking by its ID for internal use.
     * 
     * @param id The ID of the booking to be retrieved.
     * @return ResponseEntity containing the booking and HTTP status.
     */
    @GetMapping("/internal/{id}")
    public ResponseEntity<Booking> getInternalBookingById(@PathVariable Long id) {
        Booking booking = service.getBookingById(id);
        if (booking == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(booking);
    }

    /**
     * Retrieve all travel packages.
     * 
     * @return ResponseEntity containing the ApiResponse with the list of packages and HTTP status.
     */
    @GetMapping("/packages")
    public ResponseEntity<ApiResponse> getAllPackages() {
        List<TravelPackageDTO> packages = service.getAllPackages();
        return ResponseEntity.ok(new ApiResponse(true, "All packages retrieved", packages));
    }

    /**
     * Retrieve a travel package by its ID.
     * 
     * @param packageId The ID of the package to be retrieved.
     * @return ResponseEntity containing the ApiResponse with the package details and HTTP status.
     */
    @GetMapping("/packages/{id}")
    public ResponseEntity<ApiResponse> getPackageById(@PathVariable("id") Long packageId) {
        TravelPackageDTO packages = service.getPackageById(packageId);
        return ResponseEntity.ok(new ApiResponse(true, "Package retrieved successfully", packages));
    }
}


package com.booking.controller;

import com.booking.dto.PaymentResponseDTO;
import com.booking.entity.Payment;
import com.booking.service.PaymentService;

import jakarta.validation.Valid;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 * Controller for handling payment-related requests.
 * 
 * This controller provides end-points for processing payments, calculating expected totals,
 * and retrieving payment details.
 */
@RestController
@RequestMapping("/api/payments")
public class PaymentController {

    @Autowired
    private PaymentService paymentService;

    /**
     * Process a payment with an optional coupon code.
     * 
     * @param payment The payment entity to be processed.
     * @param couponCode The optional coupon code for discount.
     * @return PaymentResponseDTO containing the details of the processed payment.
     */
    @PostMapping
    public PaymentResponseDTO process(
    		@Valid @RequestBody Payment payment,
            @RequestParam(required = false) String couponCode) {

        Payment savedPayment = paymentService.processPayment(payment, couponCode);

        PaymentResponseDTO response = new PaymentResponseDTO();
        response.setPaymentId(savedPayment.getPaymentId());
        response.setUserId(savedPayment.getUserId());
        response.setBookingId(savedPayment.getBookingId());
        response.setAmount(savedPayment.getAmount());
        response.setStatus(savedPayment.getStatus());
        response.setPaymentMethod(savedPayment.getPaymentMethod());
        response.setCurrency(savedPayment.getCurrency());

        return response;
    }

    /**
     * Calculate the total payable amount before actual payment.
     * 
     * @param bookingId The ID of the booking.
     * @param couponCode The optional coupon code for discount.
     * @return A map containing the total payable amount.
     */
    @GetMapping("/expected-total/{bookingId}")
    public Map<String, Double> getExpectedTotal(
            @PathVariable Long bookingId,
            @RequestParam(required = false) String couponCode) {

        double total = paymentService.calculateExpectedTotal(bookingId, couponCode);
        return Collections.singletonMap("totalPayable", total);
    }

    /**
     * Retrieve all payments.
     * 
     * @return A list of all payments.
     */
    @GetMapping
    public List<Payment> getAll() {
        return paymentService.getAllPayments();
    }

    /**
     * Retrieve a payment by its ID.
     * 
     * @param id The ID of the payment to be retrieved.
     * @return The payment entity.
     */
    @GetMapping("/{id}")
    public Payment getById(@PathVariable Long id) {
        return paymentService.getPaymentById(id);
    }
}


package com.booking.dto;

import lombok.Data;
 
/**
 * DTO to carry insurance-related data between the Booking module and the Insurance module.
 */
@Data
public class InsuranceRequestDTO {
   
    private Integer insuranceId;

    private Long userId;
 
    private Long bookingId;  // To be updated after successful payment
 
    private String coverageDetails;
 
    private String coverageType;
 
    private double price;
 
    private String provider;
 
    private String status;  // e.g., "PENDING", "ACTIVE", "CANCELLED"
}
 
package com.booking.service;

import com.booking.client.TravelPackageClient;
import com.booking.client.TravelInsuranceClient;
import com.booking.client.UserClient;
import com.booking.dto.BookingDTO;
import com.booking.dto.TravelPackageDTO;
import com.booking.dto.UserDTO;
import com.booking.entity.Booking;
import com.booking.repository.BookingRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import java.time.LocalDate;
import java.util.List;
import java.util.logging.Logger;

/**
 * Service class for handling booking-related operations.
 * 
 * This class provides methods for creating, retrieving, updating, and deleting bookings.
 */
@Service
public class BookingService {

    @Autowired
    private BookingRepository bookingRepo;

    @Autowired
    private TravelPackageClient travelPackageClient;

    @Autowired
    private TravelInsuranceClient travelInsuranceClient;

    @Autowired
    private UserClient userClient;

    private static final Logger logger = Logger.getLogger(BookingService.class.getName());

    /**
     * Create a new booking.
     * 
     * @param bookingRequest The booking entity to be created.
     * @return BookingDTO containing the details of the created booking.
     */
    public BookingDTO createBooking(Booking bookingRequest) {
        Long userId = bookingRequest.getUserId();
        Long packageId = bookingRequest.getPackageId();
        Integer insuranceId = bookingRequest.getInsuranceId();

        logger.info("Creating booking for userId: " + userId + " and packageId: " + packageId);

        // 1. Validate User
        UserDTO user;
        try {
            user = userClient.getCustomerById(userId);
            if (user == null || !"CUSTOMER".equalsIgnoreCase(user.getRole())) {
                throw new RuntimeException("User is not a valid CUSTOMER.");
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            throw new RuntimeException("Failed to fetch user details: " + ex.getMessage());
        }

        // 2. Validate Package
        TravelPackageDTO travelPackage;
        try {
            travelPackage = travelPackageClient.getPackageById(packageId);
            if (travelPackage == null) {
                throw new IllegalArgumentException("Invalid travel package ID.");
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            throw new RuntimeException("Failed to fetch package details: " + ex.getMessage());
        }

        // 3. Validate Insurance (optional)
        if (insuranceId != null && insuranceId > 0) {
            try {
                boolean exists = travelInsuranceClient.validateInsurance(insuranceId);
                if (!exists) {
                    throw new IllegalArgumentException("Selected Insurance ID is invalid.");
                }
            } catch (Exception ex) {
                ex.printStackTrace();
                throw new RuntimeException("Failed to validate insurance: " + ex.getMessage());
            }
        }

        // 4. Create and save booking
        Booking booking = new Booking();
        booking.setUserId(userId);
        booking.setPackageId(packageId);
        booking.setInsuranceId(insuranceId);
        booking.setTripStartDate(travelPackage.getTripStartDate());
        booking.setTripEndDate(travelPackage.getTripEndDate());
        booking.setStatus("PENDING");

        Booking savedBooking = bookingRepo.save(booking);

        // 5. Build response DTO
        BookingDTO dto = new BookingDTO();
        dto.setBookingId(savedBooking.getBookingId());
        dto.setUserId(userId);
        dto.setPackageId(packageId);
        dto.setInsuranceId(insuranceId);
        dto.setTripStartDate(savedBooking.getTripStartDate());
        dto.setTripEndDate(savedBooking.getTripEndDate());
        dto.setStatus(savedBooking.getStatus());
        dto.setPaymentId(savedBooking.getPaymentId());

        logger.info("Booking created successfully with bookingId: " + savedBooking.getBookingId());
        return dto;
    }
    /**
     * Retrieve all bookings.
     * 
     * @return A list of all bookings.
     */
    public List<Booking> getAllBookings() {
        return bookingRepo.findAll();
    }

    /**
     * Retrieve a booking by its ID.
     * 
     * @param id The ID of the booking to be retrieved.
     * @return The booking entity.
     */
    public Booking getBookingById(Long id) {
        return bookingRepo.findById(id).orElse(null);
    }

    /**
     * Retrieve a booking by its ID for internal use.
     * 
     * @param id The ID of the booking to be retrieved.
     * @return The booking entity.
     */
    public Booking getInternalBookingById(Long id) {
        return bookingRepo.findById(id).orElse(null);
    }

    /**
     * Delete a booking by its ID.
     * 
     * @param id The ID of the booking to be deleted.
     */
    public void deleteBooking(Long id) {
        bookingRepo.deleteById(id);
    }

    /**
     * Cancel a booking by its ID.
     * 
     * @param bookingId The ID of the booking to be canceled.
     * @return ResponseEntity containing the cancellation status and HTTP status.
     */
    public ResponseEntity<String> cancelBooking(Long bookingId) {
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) {
            return ResponseEntity.badRequest().body("Booking not found.");
        }
        LocalDate today = LocalDate.now();
        if (booking.getTripStartDate().minusDays(7).isBefore(today)) {
            return ResponseEntity.badRequest().body("Cancellation not allowed. Must cancel at least 7 days before departure.");
        }
        booking.setStatus("CANCELLED");
        bookingRepo.save(booking);
        return ResponseEntity.ok("Booking cancelled successfully.");
    }

    /**
     * Retrieve bookings by user ID.
     * 
     * @param userId The ID of the user whose bookings are to be retrieved.
     * @return A list of bookings associated with the user ID.
     */
    public List<Booking> getBookingsByUserId(Long userId) {
        return bookingRepo.findByUserId(userId);
    }

    /**
     * Check if a user has completed a package.
     * 
     * @param userId The ID of the user.
     * @param packageId The ID of the package.
     * @return boolean indicating whether the user has completed the package.
     */
    public boolean hasUserCompletedPackage(Long userId, String packageId) {
        List<Booking> bookings = bookingRepo.findByUserId(userId);
        LocalDate today = LocalDate.now();
        return bookings.stream()
            .anyMatch(b ->
                String.valueOf(b.getPackageId()).equals(packageId) &&
                "CONFIRMED".equalsIgnoreCase(b.getStatus()) &&
                !b.getTripEndDate().isAfter(today) // includes today
            );
    }

    /**
     * Retrieve all travel packages.
     * 
     * @return A list of TravelPackageDTO representing all travel packages.
     */
    public List<TravelPackageDTO> getAllPackages() {
        return travelPackageClient.getAllPackages();
    }

    /**
     * Retrieve a travel package by its ID.
     * 
     * @param packageId The ID of the travel package to be retrieved.
     * @return The TravelPackageDTO representing the travel package.
     */
    public TravelPackageDTO getPackageById(Long packageId) {
        return travelPackageClient.getPackageById(packageId);
    }
}


package com.booking.service;

import com.booking.client.TravelPackageClient;
import com.booking.client.TravelInsuranceClient;
import com.booking.dto.OfferDTO;
import com.booking.dto.TravelPackageDTO;
import com.booking.entity.Booking;
import com.booking.entity.Payment;
import com.booking.exception.CustomBusinessException;
import com.booking.repository.BookingRepository;
import com.booking.repository.PaymentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

/**
 * Service class for handling payment-related operations.
 * This class provides methods for processing payments, calculating expected totals,
 * and retrieving payment details.
 */
@Service
public class PaymentService {

    @Autowired
    private PaymentRepository paymentRepo;

    @Autowired
    private BookingRepository bookingRepo;

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private TravelPackageClient travelPackageClient;

    @Autowired
    private TravelInsuranceClient travelInsuranceClient;

    private static final Logger log = LoggerFactory.getLogger(PaymentService.class);

    /**
     * Process a payment with an optional coupon code.
     * 
     * @param payment The payment entity to be processed.
     * @param couponCodeApplied The optional coupon code for discount.
     * @return The processed Payment entity.
     */
    public Payment processPayment(Payment payment, String couponCodeApplied) {
        Optional<Payment> existingPayment = paymentRepo.findByBookingIdAndUserId(payment.getBookingId(), payment.getUserId());

        if (existingPayment.isPresent()) {
            throw new CustomBusinessException("Payment already made for this booking by this user.");
        }

        Long bookingId = payment.getBookingId();
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) {
            throw new IllegalArgumentException("Booking with ID " + bookingId + " not found.");
        }

        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) {
            throw new IllegalArgumentException("Invalid package ID associated with booking.");
        }

        double packagePrice = pkg.getPrice();
        double insurancePrice = 0.0;
        if (booking.getInsuranceId() != null && booking.getInsuranceId() > 0) {
            try {
                insurancePrice = travelInsuranceClient.getInsurancePriceByInsuranceId(booking.getInsuranceId().intValue());
            } catch (Exception e) {
                throw new IllegalArgumentException("Failed to fetch insurance price. Verify Insurance Service is reachable.");
            }
        }

        double discountAmount = 0.0;
        if (couponCodeApplied != null && pkg.getOffer() != null) {
            OfferDTO offer = pkg.getOffer();
            if (couponCodeApplied.equalsIgnoreCase(offer.getCouponCode()) && offer.isActive()) {
                discountAmount = (packagePrice * offer.getDiscountPercentage()) / 100.0;
                System.out.println("Coupon applied. Discount amount: " + discountAmount);
            }
        }

        double expectedTotal = packagePrice + insurancePrice - discountAmount;

        if (Math.abs(payment.getAmount() - expectedTotal) > 0.01) {
            log.warn("Payment mismatch: paid={}, expected={}", payment, expectedTotal);
            throw new IllegalArgumentException("Payment amount mismatch. Expected: " + expectedTotal);
        }

        if (!payment.getPaymentMethod().equalsIgnoreCase("Credit Card") &&
            !payment.getPaymentMethod().equalsIgnoreCase("Debit Card")) {
            throw new IllegalArgumentException("Only Credit Card or Debit Card accepted.");
        }

        if (payment.getCardNumber() == null || !payment.getCardNumber().matches("\\d{16}")) {
            throw new IllegalArgumentException("Invalid card number.");
        }

        if (payment.getCvv() == null || !payment.getCvv().matches("\\d{3}")) {
            throw new IllegalArgumentException("Invalid CVV.");
        }

        if (payment.getAtmPin() == null || !payment.getAtmPin().matches("\\d{4}")) {
            throw new IllegalArgumentException("Invalid ATM PIN.");
        }

        if (payment.getExpiryDate() == null || !payment.getExpiryDate().matches("\\d{2}/\\d{2}")) {
            throw new IllegalArgumentException("Expiry date format invalid.");
        }

        String[] parts = payment.getExpiryDate().split("/");
        int expMonth = Integer.parseInt(parts[0]);
        int expYear = 2000 + Integer.parseInt(parts[1]);

        int currentMonth = LocalDate.now().getMonthValue();
        int currentYear = LocalDate.now().getYear();

        if (expMonth < 1 || expMonth > 12 || expYear < currentYear ||
           (expYear == currentYear && expMonth < currentMonth)) {
            throw new IllegalArgumentException("Card has expired.");
        }

        payment.setStatus("PAID");
        Payment savedPayment = paymentRepo.save(payment);

        booking.setStatus("CONFIRMED");
        booking.setPaymentId(savedPayment.getPaymentId());
        bookingRepo.save(booking);

        if (insurancePrice > 0.0) {
            travelInsuranceClient.updateInsuranceBookingId(booking.getInsuranceId().intValue(), booking.getBookingId());
        }

        notificationService.notifyCustomer(booking, savedPayment);
        notificationService.notifyTravelAgent(booking, savedPayment);

        return savedPayment;
    }

    /**
     * Calculate the total payable amount before actual payment.
     * 
     * @param bookingId The ID of the booking.
     * @param couponCodeApplied The optional coupon code for discount.
     * @return The total payable amount.
     */
    public double calculateExpectedTotal(Long bookingId, String couponCodeApplied) {
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) throw new IllegalArgumentException("Booking not found");

        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) throw new IllegalArgumentException("Package not found");

        double packagePrice = pkg.getPrice();

        double insurancePrice = 0.0;
        if (booking.getInsuranceId() != null && booking.getInsuranceId() > 0) {
            insurancePrice = travelInsuranceClient.getInsurancePriceByInsuranceId(booking.getInsuranceId().intValue());
        }

        double discountAmount = 0.0;
        if (couponCodeApplied != null && pkg.getOffer() != null) {
            OfferDTO offer = pkg.getOffer();
            if (couponCodeApplied.equalsIgnoreCase(offer.getCouponCode()) && offer.isActive()) {
                discountAmount = (packagePrice * offer.getDiscountPercentage()) / 100.0;
            }
        }

        return packagePrice + insurancePrice - discountAmount;
    }

    /**
     * Retrieve all payments.
     * 
     * @return A list of all payments.
     */
    public List<Payment> getAllPayments() {
        return paymentRepo.findAll();
    }

    /**
     * Retrieve a payment by its ID.
     * 
     * @param id The ID of the payment to be retrieved.
     * @return The payment entity.
     */
    public Payment getPaymentById(Long id) {
        return paymentRepo.findById(id).orElse(null);
    }
}

spring.application.name=TravelBooking-PaymentModule
spring.datasource.url=jdbc:mysql://localhost:3306/booking_db
server.port=8086
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
logging.level.org.hibernate.SQL=debug
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=indhaanman@gmail.com
spring.mail.password=ibzbwveckpfjibey
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

spring.cloud.compatibility-verifier.enabled=false

# optional:Srt timeout and logging
spring.cloud.openfeign.client.config.default.connectTimeout=5000
spring.cloud.openfeign.client.config.default.readTimeout=5000


spring.cloud.openfeign.client.config.default.loggerLevel=full


# Eureka Client Configuration
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
eureka.instance.prefer-ip-address=true


#debug=true
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true

logging.level.root=DEBUG
logging.level.org.springframework.web=DEBUG


<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
 
    <modelVersion>4.0.0</modelVersion>
 
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
 
    <groupId>com.booking</groupId>
    <artifactId>TravelBooking_PaymentModule</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>TravelBooking_PaymentModule</name>
    <properties>
        <java.version>17</java.version>
    </properties>
 
    <!-- Spring Cloud BOM -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>2024.0.1</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
 
    <dependencies>
        <!-- Spring Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!--Eureka Client Dependency-->
        <dependency>
    		<groupId>org.springframework.cloud</groupId>
    		<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>    
		</dependency>
 
 
        <!-- Thymeleaf (optional) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
		<dependency>
    	<groupId>org.projectlombok</groupId>
    	<artifactId>lombok</artifactId>
    	<version>1.18.30</version> <!-- Use the latest version if needed -->
    	<scope>provided</scope>
		</dependency>
 
        <!-- Spring Data JPA -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
 
        <!-- MySQL Connector -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.33</version>
        </dependency>
 
        <!-- Spring Cloud OpenFeign -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <!--Dependency for load balancing-->
        <dependency>
   			<groupId>org.springframework.cloud</groupId>
    		<artifactId>spring-cloud-starter-loadbalancer</artifactId>
		</dependency>
 
 
        <!-- Spring Mail -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
 
        <!-- Web Services (optional) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web-services</artifactId>
        </dependency>
 
        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
       
 
        
        <!-- https://mvnrepository.com/artifact/org.mockito/mockito-core -->
		<!-- https://mvnrepository.com/artifact/org.mockito/mockito-core -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>5.18.0</version>
    <scope>test</scope>
</dependency>
        
        <dependency>
			<groupId>jakarta.validation</groupId>
			<artifactId>jakarta.validation-api</artifactId>
			<version>3.0.2</version>
		</dependency>
		
    </dependencies>
 
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
 
</project>



